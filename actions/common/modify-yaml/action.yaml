name: 'Common Modify YAML'
description: 'A action to modify a value in a YAML file while strictly preserving comments and structure'
inputs:
  file:
    description: 'Path to the YAML file'
    required: true
  key:
    description: 'Dot-notation key path'
    required: true
  value:
    description: 'Value to set'
    required: true
outputs:
  old-value:
    description: 'Value before modification'
    value: ${{ steps.modify.outputs.old-value }}
  new-value:
    description: 'Value after modification'
    value: ${{ steps.modify.outputs.new-value }}
runs:
  using: 'composite'
  steps:
    - name: Modify YAML
      id: modify
      shell: python
      env:
        INPUT_FILE: ${{ inputs.file }}
        INPUT_KEY: ${{ inputs.key }}
        INPUT_VALUE: ${{ inputs.value }}
      run: |
        import os
        import sys
        import subprocess
        import re
        
        file_path = os.environ['INPUT_FILE']
        key_path = os.environ['INPUT_KEY']
        new_value = os.environ['INPUT_VALUE']
        
        # Validate file exists
        if not os.path.exists(file_path):
            print(f"::error::File not found: {file_path}")
            sys.exit(1)
        
        # Use yq to validate and get old value
        result = subprocess.run(['yq', 'eval', f'.{key_path}', file_path], 
                              capture_output=True, text=True)
        old_value = result.stdout.strip()
        
        if old_value == 'null' or result.returncode != 0:
            print(f"::error::Key '{key_path}' not found in {file_path}")
            sys.exit(1)
        
        print(f"Old value: {old_value}")
        
        # Get line number by parsing the file structure in Python
        # This is more reliable than yq for nested keys and duplicate names
        def find_line_number(lines, key_path):
            parts = key_path.split('.')
            current_idx = 0
            parent_indents = [] # Stack of indents for matched path parts
            
            for i, line in enumerate(lines):
                stripped = line.lstrip()
                # Skip comments and empty lines
                if not stripped or stripped.startswith('#'):
                    continue
                    
                indent = len(line) - len(stripped)
                
                # Check if we left the scope of previous parents
                # If indent <= last matched parent's indent, we popped out of that block
                while parent_indents and indent <= parent_indents[-1]:
                    parent_indents.pop()
                    current_idx -= 1
                
                # Match the current expected part
                target = parts[current_idx]
                
                # Regex matches "key:" or "key: value"
                # STRICT match on key name to avoid partial matches (e.g. 'api' vs 'api_key')
                if re.match(rf'^{re.escape(target)}\s*:', stripped):
                    # If this is the final part of the key
                    if current_idx == len(parts) - 1:
                        return i + 1 # Return 1-based line number (to match prev logic)
                    
                    # Found a parent, go deeper
                    parent_indents.append(indent)
                    current_idx += 1
            
            return -1

        # Read all lines first
        with open(file_path, 'r') as f:
            lines = f.readlines()
            
        line_num = find_line_number(lines, key_path)
        
        if line_num == -1:
            print(f"::error::Could not find line number for key: {key_path}")
            sys.exit(1)
            
        print(f"Found '{key_path}' on line {line_num}")
        
        # Detect value type and apply quoting if needed
        # We modify 'new_value' directly to avoid variable name confusion
        if new_value in ('true', 'false'):
            pass # Keep as is
        elif re.match(r'^-?[0-9]+\.?[0-9]*$', new_value):
            pass # Keep as is
        else:
            # String - only quote if it contains characters that require quoting
            # YAML needs quotes for: leading/trailing spaces, ": " sequence, certain special chars at start
            needs_quotes = (
                new_value != new_value.strip() or  # leading/trailing whitespace
                ': ' in new_value or           # colon-space is a key-value separator
                new_value.startswith(('#', '&', '*', '!', '|', '>', '@', '`', '%', '-')) or  # special start chars
                any(c in new_value for c in ':{}[]#,*&?') or # Special chars that might confuse parsers
                new_value.lower() in ('yes', 'no', 'on', 'off', 'null', '~')  # reserved words
            )
            
            if needs_quotes:
                # Add quotes and escape existing quotes
                new_value = f'"{new_value.replace(chr(34), chr(92)+chr(34))}"'
        
        # Modify the specific line
        target_line = lines[line_num - 1]  # line_num is 1-indexed
        final_key = key_path.split('.')[-1]
        
        # Extract indent and comment
        indent_match = re.match(r'^(\s*)', target_line)
        indent = indent_match.group(1) if indent_match else ''
        
        comment_match = re.search(r'(#.*)$', target_line)
        comment = '  ' + comment_match.group(1) if comment_match else ''
        
        # Replace the line
        lines[line_num - 1] = f'{indent}{final_key}: {new_value}{comment}\n'
        
        # Write back
        with open(file_path, 'w') as f:
            f.writelines(lines)
        
        print(f"âœ… Modified {key_path} (line {line_num}) to: {new_value}")
        
        # Set outputs
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f'old-value={old_value}\n')
            f.write(f'new-value={new_value}\n')
