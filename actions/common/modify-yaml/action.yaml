name: 'Common Modify YAML'
description: 'A action to modify a value in a YAML file while strictly preserving comments and structure'
inputs:
  file:
    description: 'Path to the YAML file'
    required: true
  key:
    description: 'Dot-notation key path'
    required: true
  value:
    description: 'Value to set'
    required: true
outputs:
  old-value:
    description: 'Value before modification'
    value: ${{ steps.modify.outputs.old-value }}
  new-value:
    description: 'Value after modification'
    value: ${{ steps.modify.outputs.new-value }}
runs:
  using: 'composite'
  steps:
    - name: Modify YAML
      id: modify
      shell: python
      env:
        INPUT_FILE: ${{ inputs.file }}
        INPUT_KEY: ${{ inputs.key }}
        INPUT_VALUE: ${{ inputs.value }}
      run: |
        import os
        import sys
        import subprocess
        import re
        
        file_path = os.environ['INPUT_FILE']
        key_path = os.environ['INPUT_KEY']
        new_value = os.environ['INPUT_VALUE']
        
        # Validate file exists
        if not os.path.exists(file_path):
            print(f"::error::File not found: {file_path}")
            sys.exit(1)
        
        # Use yq to validate and get old value
        result = subprocess.run(['yq', 'eval', f'.{key_path}', file_path], 
                              capture_output=True, text=True)
        old_value = result.stdout.strip()
        
        if old_value == 'null' or result.returncode != 0:
            print(f"::error::Key '{key_path}' not found in {file_path}")
            sys.exit(1)
        
        print(f"Old value: {old_value}")
        
        # Get line number using yq
        result = subprocess.run(['yq', 'eval', f'.{key_path} | line', file_path],
                              capture_output=True, text=True)
        line_num_str = result.stdout.strip()
        
        if not line_num_str or line_num_str == 'null':
            print(f"::error::Could not determine line number for key: {key_path}")
            sys.exit(1)
        
        line_num = int(line_num_str)
        final_key = key_path.split('.')[-1]
        
        # Detect value type
        if new_value in ('true', 'false'):
            formatted_value = new_value
        elif re.match(r'^-?[0-9]+\.?[0-9]*$', new_value):
            formatted_value = new_value
        else:
            # String - only quote if it contains characters that require quoting
            # YAML needs quotes for: leading/trailing spaces, ": " sequence, certain special chars at start
            needs_quotes = (
                new_value != new_value.strip() or  # leading/trailing whitespace
                ': ' in new_value or           # colon-space is a key-value separator
                new_value.startswith(('#', '&', '*', '!', '|', '>', '@', '`', '%', '-')) or  # special start chars
                any(c in new_value for c in ':{}[]#,*&?') or # Special chars that might confuse parsers
                new_value.lower() in ('yes', 'no', 'on', 'off', 'null', '~')  # reserved words
            )
            
            if needs_quotes:
                formatted_value = f'"{new_value.replace(chr(34), chr(92)+chr(34))}"'
            else:
                formatted_value = new_value
        
        # Read all lines
        with open(file_path, 'r') as f:
            lines = f.readlines()
        
        # Modify the specific line
        target_line = lines[line_num - 1]  # line_num is 1-indexed
        
        # Extract indent and comment
        indent_match = re.match(r'^(\s*)', target_line)
        indent = indent_match.group(1) if indent_match else ''
        
        comment_match = re.search(r'(#.*)$', target_line)
        comment = '  ' + comment_match.group(1) if comment_match else ''
        
        # Replace the line
        lines[line_num - 1] = f'{indent}{final_key}: {formatted_value}{comment}\n'
        
        # Write back
        with open(file_path, 'w') as f:
            f.writelines(lines)
        
        print(f"âœ… Modified {key_path} (line {line_num}) to: {new_value}")
        
        # Set outputs
        with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            f.write(f'old-value={old_value}\n')
            f.write(f'new-value={new_value}\n')
