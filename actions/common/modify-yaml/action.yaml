name: 'Common Modify YAML'
description: 'A action to modify a value in a YAML file while strictly preserving comments and structure'
inputs:
  file:
    description: 'Path to the YAML file'
    required: true
  key:
    description: 'Dot-notation key path'
    required: true
  value:
    description: 'Value to set'
    required: true
outputs:
  old-value:
    description: 'Value before modification'
    value: ${{ steps.set-outputs.outputs.old-value }}
  new-value:
    description: 'Value after modification'
    value: ${{ steps.set-outputs.outputs.new-value }}
runs:
  using: 'composite'
  steps:
    - name: Validate and Get Old Value
      id: old
      shell: bash
      run: |
        FILE="${{ inputs.file }}"
        KEY="${{ inputs.key }}"
        
        if [ ! -f "$FILE" ]; then
          echo "::error::File not found: $FILE"
          exit 1
        fi
        
        # Use yq to validate structure and get old value
        OLD_VALUE=$(yq eval ".$KEY" "$FILE")
        if [ "$OLD_VALUE" == "null" ]; then
          echo "::error::Key '$KEY' not found in $FILE"
          exit 1
        fi
        
        echo "value=$OLD_VALUE" >> "$GITHUB_OUTPUT"
        echo "Old value: $OLD_VALUE"
    
    - name: Modify YAML (Text-Based for Perfect Preservation)
      shell: bash
      run: |
        FILE="${{ inputs.file }}"
        KEY="${{ inputs.key }}"
        VALUE="${{ inputs.value }}"
        
        # Extract the final key name from dot notation
        FINAL_KEY="${KEY##*.}"
        
        # Detect value type and format appropriately
        if [ "$VALUE" == "true" ] || [ "$VALUE" == "false" ]; then
          FORMATTED_VALUE="$VALUE"
        elif [[ "$VALUE" =~ ^-?[0-9]+\.?[0-9]*$ ]]; then
          FORMATTED_VALUE="$VALUE"
        else
          # String - check if it needs quotes
          if [[ "$VALUE" =~ [:{}[\],\&*#?|<>=!%@\`\ ] ]]; then
            FORMATTED_VALUE="\"${VALUE//\"/\\\"}\""
          else
            FORMATTED_VALUE="$VALUE"
          fi
        fi
        
        # Use awk to replace ONLY the target line, preserving everything else
        # This keeps ALL formatting: blank lines, comments, indentation
        awk -v key="$FINAL_KEY" -v val="$FORMATTED_VALUE" '
        {
          if ($0 ~ "^[[:space:]]*" key "[[:space:]]*:") {
            # Found the key line - extract indent and any inline comment
            match($0, /^([[:space:]]*)/, indent)
            match($0, /(#.*)$/, comment)
            if (comment[1]) {
              print indent[1] key ": " val "  " comment[1]
            } else {
              print indent[1] key ": " val
            }
          } else {
            print $0
          }
        }
        ' "$FILE" > "$FILE.tmp" && mv "$FILE.tmp" "$FILE"
        
        echo "âœ… Modified $KEY to: $VALUE"
    
    - name: Set Outputs
      id: set-outputs
      shell: bash
      run: |
        echo "old-value=${{ steps.old.outputs.value }}" >> "$GITHUB_OUTPUT"
        echo "new-value=${{ inputs.value }}" >> "$GITHUB_OUTPUT"
