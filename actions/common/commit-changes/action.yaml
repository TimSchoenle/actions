name: 'Commit Changes'
description: 'Commits changes using the GitHub API to ensure verified bot commits.'

inputs:
  commit_message:
    description: 'The commit message'
    required: true
  token:
    description: 'The GitHub token to use (must be an App installation token for verified commits)'
    required: true
  repository:
    description: 'Repository name to commit to (e.g. owner/repo)'
    required: false
    default: ${{ github.repository }}
  branch:
    description: 'Branch to commit to'
    required: false
    default: ${{ github.head_ref || github.ref_name }}
  empty:
    description: Allow making an empty commit if there are no changes.
    required: false
    default: 'false'
  file_pattern:
    description: 'File pattern to commit'
    required: false
    default: '.'

outputs:
  commit_hash:
    description: 'The SHA of the created commit'
    value: ${{ steps.commit.outputs.commit-hash }}
  commit_url:
    description: 'The URL of the created commit.'
    value: ${{ steps.commit.outputs.commit-url }}
  changes_detected:
    description: 'True if changes were committed'
    value: ${{ steps.compatibility.outputs.changes_detected }}

runs:
  using: 'composite'
  steps:
    - name: Capture Caller Subdirectory
      id: caller
      shell: bash
      run: |
        set -euo pipefail

        CALLER_DIR="$(pwd -P)"
        WORKSPACE_DIR="$(cd "$GITHUB_WORKSPACE" && pwd -P)"

        if [[ "$CALLER_DIR" == "$WORKSPACE_DIR" ]]; then
          rel=""
        elif [[ "$CALLER_DIR" == "$WORKSPACE_DIR/"* ]]; then
          rel="${CALLER_DIR#"$WORKSPACE_DIR"/}"
        else
          echo "Caller directory is outside GITHUB_WORKSPACE. Refusing to continue."
          echo "caller_dir=$CALLER_DIR"
          echo "workspace_dir=$WORKSPACE_DIR"
          exit 1
        fi

        echo "caller_rel=$rel" >> "$GITHUB_OUTPUT"

    - name: Init Git Settings
      id: init
      shell: bash
      working-directory: ${{ github.workspace }}
      run: |
        set -euo pipefail
        git config core.fileMode false

    - name: Parse File Pattern Input (relative to caller dir)
      id: parse
      shell: bash
      working-directory: ${{ github.workspace }}
      env:
        FILE_PATTERN: ${{ inputs.file_pattern }}
        CALLER_REL: ${{ steps.caller.outputs.caller_rel }}
      run: |
        set -euo pipefail

        if [ -z "${FILE_PATTERN:-}" ] || [ "$FILE_PATTERN" = "." ]; then
          echo "use_filter=false" >> "$GITHUB_OUTPUT"
          echo "raw_specs=" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        read -r -a RAW_SPECS <<< "$FILE_PATTERN"

        PREFIX=""
        if [ -n "${CALLER_REL:-}" ]; then
          PREFIX="${CALLER_REL%/}/"
        fi

        REWRITTEN=()
        for spec in "${RAW_SPECS[@]}"; do
          # Normalize leading "./"
          spec="${spec#./}"

          # Keep explicit git pathspec magic untouched (advanced users)
          if [[ "$spec" == :\(*\)* ]]; then
            REWRITTEN+=("$spec")
            continue
          fi

          # Keep empty and "." as-is (will effectively disable filtering later anyway)
          if [ -z "$spec" ] || [ "$spec" = "." ]; then
            REWRITTEN+=("$spec")
            continue
          fi

          # Disallow absolute paths
          if [[ "$spec" == /* ]]; then
            echo "Absolute paths are not allowed in file_pattern: $spec" >&2
            exit 1
          fi

          # Prefix with caller subdir if present
          REWRITTEN+=("${PREFIX}${spec}")
        done

        {
          echo "use_filter=true"
          echo "raw_specs<<__EOF__"
          printf '%s\n' "${REWRITTEN[@]}"
          echo "__EOF__"
        } >> "$GITHUB_OUTPUT"

    - name: Build Git Pathspecs
      id: pathspecs
      shell: bash
      working-directory: ${{ github.workspace }}
      env:
        USE_FILTER: ${{ steps.parse.outputs.use_filter }}
        RAW_SPECS_NL: ${{ steps.parse.outputs.raw_specs }}
      run: |
        set -euo pipefail

        if [ "$USE_FILTER" != "true" ]; then
          echo "pathspecs=" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        mapfile -t RAW_SPECS < <(printf '%s\n' "$RAW_SPECS_NL")

        PATHSPECS=()
        for spec in "${RAW_SPECS[@]}"; do
          if [[ "$spec" == :\(*\)* ]]; then
            PATHSPECS+=("$spec")
          elif [[ "$spec" == *"*"* || "$spec" == *"?"* || "$spec" == *"["* ]]; then
            PATHSPECS+=(":(glob)$spec")
          else
            PATHSPECS+=("$spec")
          fi
        done

        {
          echo "pathspecs<<__EOF__"
          printf '%s\n' "${PATHSPECS[@]}"
          echo "__EOF__"
        } >> "$GITHUB_OUTPUT"

    - name: Collect Changed Files (tracked + untracked, no ignored)
      id: files
      shell: bash
      working-directory: ${{ github.workspace }}
      env:
        USE_FILTER: ${{ steps.parse.outputs.use_filter }}
        PATHSPECS_NL: ${{ steps.pathspecs.outputs.pathspecs }}
      run: |
        set -euo pipefail

        CHANGED_Z="${RUNNER_TEMP}/commit-changes-changed-files.z"
        : > "$CHANGED_Z"

        if [ "$USE_FILTER" = "true" ]; then
          mapfile -t SPECS < <(printf '%s\n' "$PATHSPECS_NL")
          git ls-files -m -o --exclude-standard -z -- "${SPECS[@]}" > "$CHANGED_Z"
        else
          git ls-files -m -o --exclude-standard -z > "$CHANGED_Z"
        fi

        echo "changed_files_z=$CHANGED_Z" >> "$GITHUB_OUTPUT"

        if [ -s "$CHANGED_Z" ]; then
          echo "has_files=true" >> "$GITHUB_OUTPUT"
        else
          echo "has_files=false" >> "$GITHUB_OUTPUT"
        fi

    - name: Format Resolved File Pattern for ghcommit
      id: resolve
      shell: bash
      env:
        HAS_FILES: ${{ steps.files.outputs.has_files }}
        CHANGED_FILES_Z: ${{ steps.files.outputs.changed_files_z }}
        ALLOW_EMPTY: ${{ inputs.empty }}
      run: |
        set -euo pipefail

        if [ "$HAS_FILES" != "true" ]; then
          if [ "$ALLOW_EMPTY" = "true" ]; then
            # ghcommit-action requires a non-empty file_pattern input.
            # Provide a *safe, non-directory* fallback that is likely to exist.
            if [ -f ".gitignore" ]; then
              echo "resolved_file_pattern=.gitignore" >> "$GITHUB_OUTPUT"
            elif [ -f "README.md" ]; then
              echo "resolved_file_pattern=README.md" >> "$GITHUB_OUTPUT"
            else
              # Last resort. Should be harmless if there are truly no changes,
              # but we prefer a concrete file above to avoid directory edge cases.
              echo "resolved_file_pattern=." >> "$GITHUB_OUTPUT"
            fi
          else
            echo "resolved_file_pattern=" >> "$GITHUB_OUTPUT"
          fi

          echo "has_changes=false" >> "$GITHUB_OUTPUT"
          echo "No file changes detected!"
          exit 0
        fi

        files=()
        while IFS= read -r -d '' f; do
          [ -z "$f" ] && continue
          [ -d "$f" ] && continue
          files+=("$f")
        done < "$CHANGED_FILES_Z"

        if [ "${#files[@]}" -eq 0 ]; then
          if [ "$ALLOW_EMPTY" = "true" ]; then
            if [ -f ".gitignore" ]; then
              echo "resolved_file_pattern=.gitignore" >> "$GITHUB_OUTPUT"
            elif [ -f "README.md" ]; then
              echo "resolved_file_pattern=README.md" >> "$GITHUB_OUTPUT"
            else
              echo "resolved_file_pattern=." >> "$GITHUB_OUTPUT"
            fi
          else
            echo "resolved_file_pattern=" >> "$GITHUB_OUTPUT"
          fi

          echo "has_changes=false" >> "$GITHUB_OUTPUT"
          echo "No file changes detected!"
          exit 0
        fi

        resolved="$(printf '%s ' "${files[@]}")"
        resolved="${resolved% }"

        echo "has_changes=true" >> "$GITHUB_OUTPUT"
        echo "resolved_file_pattern=$resolved" >> "$GITHUB_OUTPUT"
        echo "File change detected!"

    - name: Commit Changes
      id: commit
      uses: planetscale/ghcommit-action@25309d8005ac7c3bcd61d3fe19b69e0fe47dbdde # v0.2.20
      if: steps.resolve.outputs.has_changes == 'true' || inputs.empty == 'true'
      with:
        commit_message: ${{ inputs.commit_message }}
        repo: ${{ inputs.repository }}
        branch: ${{ inputs.branch }}
        empty: ${{ inputs.empty }}
        file_pattern: ${{ steps.resolve.outputs.resolved_file_pattern }}
      env:
        GITHUB_TOKEN: ${{ inputs.token }}

    - name: Set Compatibility Outputs
      id: compatibility
      shell: bash
      env:
        COMMIT_HASH: ${{ steps.commit.outputs.commit-hash }}
      run: |
        if [ -n "$COMMIT_HASH" ]; then
          echo "changes_detected=true" >> "$GITHUB_OUTPUT"
        else
          echo "changes_detected=false" >> "$GITHUB_OUTPUT"
        fi
