name: release-please

on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions: {}

jobs:
  release-please:
    name: Release Please
    runs-on: ubuntu-latest
    permissions:
      contents: write # to create release commits and tags
      pull-requests: write # to manage release PRs
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: Generate Bot Token
        id: generate_token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        with:
          app-id: ${{ secrets.RELEASE_BOT_APP_ID }}
          private-key: ${{ secrets.RELEASE_BOT_PRIVATE_KEY }}

      - name: Run release-please
        id: release
        uses: googleapis/release-please-action@16a9c90856f42705d54a6fda1823352bdc62cf38 # v4
        with:
          token: ${{ steps.generate_token.outputs.token }}

  publish-releases:
    name: Publish Custom Releases
    needs: release-please
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: Generate Bot Token
        id: generate_token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        with:
          app-id: ${{ secrets.RELEASE_BOT_APP_ID }}
          private-key: ${{ secrets.RELEASE_BOT_PRIVATE_KEY }}
          permission-contents: write
          permission-workflows: write
          permission-pull-requests: write
          permission-metadata: read

      - name: Checkout Repository
        uses: actions/checkout@v6
        with:
          token: ${{ steps.generate_token.outputs.token }}
          fetch-depth: 0 # We need history for diffing manifests

      - name: Configure Git Config
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
          APP_SLUG: ${{ steps.generate_token.outputs.app-slug }}
        shell: bash
        run: |
          set -e
          echo "Setting up Bot Identity..."

          # Use the app-slug output to construct the bot username
          # Format: app-slug[bot]
          BOT_USERNAME="${APP_SLUG}[bot]"

          # Retrieve the Bot User ID from the public API
          # This avoids the 403 on /user endpoint
          BOT_ID=$(gh api "/users/${BOT_USERNAME}" --jq .id)

          # Construct the noreply email
          BOT_EMAIL="${BOT_ID}+${BOT_USERNAME}@users.noreply.github.com"

          echo "Configuring git user: ${BOT_USERNAME} <${BOT_EMAIL}>"
          git config user.name "$BOT_USERNAME"
          git config user.email "$BOT_EMAIL"

      - name: Publish Custom Releases
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        shell: bash
        run: |
          set -e
          set -x  # Verbose execution

          # 1. Get Manifest
          CURR_MANIFEST=$(git show HEAD:.release-please-manifest.json)

          # 2. Get all workflow packages
          PACKAGES=$(echo "$CURR_MANIFEST" | jq -r '
            to_entries | .[] | 
            select(.key | startswith("workflows/")) | 
            "\(.key)|\(.value)"
          ')

          if [ -z "$PACKAGES" ]; then
            echo "No workflow packages configured."
            exit 0
          fi

          # 3. Loop through packages and reconcile
          echo "$PACKAGES" | while IFS="|" read -r PKG VERSION; do
            if [ -z "$PKG" ]; then continue; fi
            
            # Derive Component Name from Path
            # Path: workflows/common/test -> workflows-common-test
            COMPONENT_NAME="workflows-$(echo "$PKG" | cut -d'/' -f2- | tr '/' '-')"
            TAG_NAME="${COMPONENT_NAME}-v${VERSION}"
            
            echo "Processing $PKG $VERSION"
            echo "  Component: $COMPONENT_NAME"
            echo "  Tag: $TAG_NAME"
            
            # Check if Tag Exists
            if git ls-remote --exit-code --tags origin "refs/tags/${TAG_NAME}" >/dev/null 2>&1; then
              echo "Tag ${TAG_NAME} already exists. Skipping release."
              continue
            fi
            
            echo "Tag ${TAG_NAME} missing. Proceeding with release."
            
            SOURCE_FILE="${PKG}/workflow.yaml"
            
            if [ ! -f "$SOURCE_FILE" ]; then
              echo "Error: Source file $SOURCE_FILE not found!"
              continue
            fi
            
            echo "Releasing $TAG_NAME"

            # --- Release Notes Extraction ---
            NOTES="Release ${PKG} ${VERSION}"
            CURRENT_SHA=$(git rev-parse HEAD)
            PR_NUMBER=$(gh pr list --search "$CURRENT_SHA" --state merged --json number --jq '.[0].number')
            
            if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
                echo "Found PR #${PR_NUMBER} for commit $CURRENT_SHA"
                PR_BODY=$(gh pr view "$PR_NUMBER" --json body --jq .body)
                if [ -n "$PR_BODY" ]; then NOTES="$PR_BODY"; fi
            else
                echo "No PR found. Using default notes."
            fi

            # --- Git Operations ---
            
            # 1. Clean Release Build
            # Branch off current HEAD (main) to preserve history
            TEMP_BRANCH="temp-release-${COMPONENT_NAME}-${VERSION}"
            git checkout -b "$TEMP_BRANCH"
            
            # Prepare content
            cat "$SOURCE_FILE" > /tmp/workflow_content.yaml
            
            # Clean Tree 
            git rm -rf .
            git clean -fdx
            
            # Restore Target
            # Filename: workflows-common-test.yaml (Standardized to component name)
            mkdir -p .github/workflows
            mv /tmp/workflow_content.yaml ".github/workflows/${COMPONENT_NAME#workflows-}.yaml"
            
            # Commit
            git add ".github/workflows/${COMPONENT_NAME#workflows-}.yaml"
            git commit -m "chore: release ${PKG} ${VERSION}"
            
            # 2. Tagging
            git tag "$TAG_NAME"
            git push origin "$TAG_NAME" -v
            
            # 3. Release Creation
            gh release create "$TAG_NAME" --title "${COMPONENT_NAME} ${VERSION}" --notes "$NOTES" -R "${{ github.repository }}"
            
            # --- Cleanup PR Labels ---
            if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
                echo "Removing 'autorelease: pending' label from PR #$PR_NUMBER"
                gh pr edit "$PR_NUMBER" --remove-label "autorelease: pending" || echo "Failed to remove label, but continuing."
            fi

            # Cleanup
            git checkout -
            git branch -D "$TEMP_BRANCH"
            
          done
