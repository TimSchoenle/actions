name: release-please

on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions: {}

jobs:
  release-please:
    name: Release Please
    runs-on: ubuntu-latest
    permissions:
      contents: write # to create release commits and tags
      pull-requests: write # to manage release PRs
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: Generate Bot Token
        id: generate_token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        with:
          app-id: ${{ secrets.RELEASE_BOT_APP_ID }}
          private-key: ${{ secrets.RELEASE_BOT_PRIVATE_KEY }}

      - name: Run release-please
        id: release
        uses: googleapis/release-please-action@16a9c90856f42705d54a6fda1823352bdc62cf38 # v4
        with:
          token: ${{ steps.generate_token.outputs.token }}

  publish-releases:
    name: Publish Custom Releases
    needs: release-please
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: Generate Bot Token
        id: generate_token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        with:
          app-id: ${{ secrets.RELEASE_BOT_APP_ID }}
          private-key: ${{ secrets.RELEASE_BOT_PRIVATE_KEY }}
          permission-contents: write
          permission-workflows: write
          permission-metadata: read

      - name: Checkout Repository
        uses: actions/checkout@v6
        with:
          token: ${{ steps.generate_token.outputs.token }}
          fetch-depth: 0 # We need history for diffing manifests

      - name: Configure Git Config
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
          APP_SLUG: ${{ steps.generate_token.outputs.app-slug }}
        shell: bash
        run: |
          set -e
          echo "Setting up Bot Identity..."

          # Use the app-slug output to construct the bot username
          # Format: app-slug[bot]
          BOT_USERNAME="${APP_SLUG}[bot]"

          # Retrieve the Bot User ID from the public API
          # This avoids the 403 on /user endpoint
          BOT_ID=$(gh api "/users/${BOT_USERNAME}" --jq .id)

          # Construct the noreply email
          BOT_EMAIL="${BOT_ID}+${BOT_USERNAME}@users.noreply.github.com"

          echo "Configuring git user: ${BOT_USERNAME} <${BOT_EMAIL}>"
          git config user.name "$BOT_USERNAME"
          git config user.email "$BOT_EMAIL"

      - name: Publish Custom Releases
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        shell: bash
        run: |
          set -e
          set -x  # Verbose execution

          # 1. Get Manifest
          CURR_MANIFEST=$(git show HEAD:.release-please-manifest.json)

          # 2. Get all workflow packages
          PACKAGES=$(echo "$CURR_MANIFEST" | jq -r '
            to_entries | .[] | 
            select(.key | startswith("workflows/")) | 
            "\(.key)|\(.value)"
          ')

          if [ -z "$PACKAGES" ]; then
            echo "No workflow packages configured."
            exit 0
          fi

          # 3. Loop through packages and reconcile
          echo "$PACKAGES" | while IFS="|" read -r PKG VERSION; do
            if [ -z "$PKG" ]; then continue; fi
            
            COMPONENT_NAME=$(echo "$PKG" | cut -d'/' -f2- | tr '/' '-')
            TAG_NAME="workflows-${COMPONENT_NAME}-v${VERSION}"
            
            echo "Checking ${PKG} ${VERSION} (Tag: ${TAG_NAME})"
            
            # Check if tag exists remotely
            if git ls-remote --exit-code --tags origin "refs/tags/${TAG_NAME}" >/dev/null 2>&1; then
              echo "Tag ${TAG_NAME} already exists. Skipping."
              continue
            fi
            
            echo "Tag ${TAG_NAME} missing. Proceeding with release."
            
            SOURCE_FILE="${PKG}/workflow.yaml"
            
            if [ ! -f "$SOURCE_FILE" ]; then
              echo "Error: Source file $SOURCE_FILE not found!"
              continue
            fi
            
            echo "Releasing $TAG_NAME"

            # 4. Git Operations
            TEMP_BRANCH="temp-release-${COMPONENT_NAME}-${VERSION}"
            
            git checkout -b "$TEMP_BRANCH"
            
            cat "$SOURCE_FILE" > /tmp/workflow_content.yaml
            
            git rm -rf .
            git clean -fdx
            
            mkdir -p .github/workflows
            mv /tmp/workflow_content.yaml ".github/workflows/${COMPONENT_NAME}.yaml"
            
            git add ".github/workflows/${COMPONENT_NAME}.yaml"
            git commit -m "chore: release ${PKG} ${VERSION}"
            
            git tag "$TAG_NAME"
            git push origin "$TAG_NAME" -v
            
            # Release
            CHANGELOG_PATH="${PKG}/CHANGELOG.md"
            NOTES="Release ${PKG} ${VERSION}"
            if git show "HEAD:${CHANGELOG_PATH}" > /dev/null 2>&1; then
               NOTES=$(git show "HEAD:${CHANGELOG_PATH}" | awk "/^## \[?${VERSION}\]?/{flag=1; next} /^## /{flag=0} flag")
            fi
            if [ -z "$NOTES" ]; then NOTES="Release ${PKG} ${VERSION}"; fi
            
            gh release create "$TAG_NAME" --title "${COMPONENT_NAME} ${VERSION}" --notes "$NOTES" -R "${{ github.repository }}"
            
            # Cleanup
            git checkout -
            git branch -D "$TEMP_BRANCH"
            
          done
