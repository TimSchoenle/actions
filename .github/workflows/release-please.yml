name: release-please

on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions: {}

jobs:
  release-please:
    name: Release Please
    runs-on: ubuntu-latest
    outputs:
      paths_released: ${{ steps.release.outputs.paths_released }}
    permissions:
      contents: write # to create release commits and tags
      pull-requests: write # to manage release PRs
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: Generate Bot Token
        id: generate_token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        with:
          app-id: ${{ secrets.RELEASE_BOT_APP_ID }}
          private-key: ${{ secrets.RELEASE_BOT_PRIVATE_KEY }}

      - name: Run release-please
        id: release
        uses: googleapis/release-please-action@16a9c90856f42705d54a6fda1823352bdc62cf38 # v4
        with:
          token: ${{ steps.generate_token.outputs.token }}

  prepare-matrix:
    name: Prepare Workflow Matrix
    needs: release-please
    if: always()
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: Checkout Repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Generate Matrix
        id: set-matrix
        shell: bash
        run: |
          MANIFEST_FILE=".release-please-manifest.json"
          if [ ! -f "$MANIFEST_FILE" ]; then
            echo "::error::Manifest file not found"
            exit 1
          fi

          # Initialize matrix JSON using a temp file to avoid subshell variable loss
          MATRIX_FILE=$(mktemp)
          echo "{\"include\":[" > "$MATRIX_FILE"

          # We need to track if we've added an item for commas, but logic is easier if we just build a list then join
          ITEMS_FILE=$(mktemp)

          # Iterate over workflow packages
          # Filter entries starting with "workflows/" and format as "key|value"
          jq -r 'to_entries[] | select(.key | startswith("workflows/")) | "\(.key)|\(.value)"' "$MANIFEST_FILE" | while IFS="|" read -r PKG VERSION; do
            if [ -z "$PKG" ]; then continue; fi
            
            # Derive Component & Tag
            # Example: workflows/foo/bar -> workflows-foo-bar
            COMPONENT_NAME="workflows-$(echo "$PKG" | cut -d'/' -f2- | tr '/' '-')"
            TAG_NAME="${COMPONENT_NAME}-v${VERSION}"
            
            # Check if tag exists remotely
            if git ls-remote --exit-code --tags origin "refs/tags/$TAG_NAME" >/dev/null 2>&1; then
              echo "Skipping $PKG $VERSION (Tag $TAG_NAME exists)"
            else
              echo "Queueing $PKG $VERSION (Tag $TAG_NAME missing)"
              echo "{\"path\":\"${PKG}\",\"version\":\"${VERSION}\"}" >> "$ITEMS_FILE"
            fi
          done

          # Join items with commas
          if [ -s "$ITEMS_FILE" ]; then
            paste -sd "," "$ITEMS_FILE" >> "$MATRIX_FILE"
          fi

          # Close JSON
          echo "]}" >> "$MATRIX_FILE"

          # Output
          # Must be single line for GITHUB_OUTPUT, use jq -c to minify
          MATRIX_JSON=$(jq -c . "$MATRIX_FILE")
          echo "Generated Matrix: $MATRIX_JSON"
          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT

  publish-workflow:
    name: Publish ${{ matrix.path }}
    needs: prepare-matrix
    if: ${{ needs.prepare-matrix.outputs.matrix != '' && fromJson(needs.prepare-matrix.outputs.matrix).include[0] != null }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}
    permissions:
      contents: write # to push release tags and commits
      pull-requests: write # to update PR labels after release
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: Generate Bot Token
        id: generate_token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        with:
          app-id: ${{ secrets.RELEASE_BOT_APP_ID }}
          private-key: ${{ secrets.RELEASE_BOT_PRIVATE_KEY }}
          permission-contents: write
          permission-workflows: write
          permission-pull-requests: write
          permission-metadata: read

      - name: Checkout Repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          token: ${{ steps.generate_token.outputs.token }}
          fetch-depth: 0
          persist-credentials: true

      - name: Configure Git Identity
        uses: TimSchoenle/actions/actions/common/setup-app-git-identity@5e76fd2889fa615725953e0a4a06d5bb5f893e86 # actions-common-setup-app-git-identity-v1.1.0
        with:
          app-slug: ${{ steps.generate_token.outputs.app-slug }}
          token: ${{ steps.generate_token.outputs.token }}

      - name: Define Variables
        id: vars
        env:
          MATRIX_PATH: ${{ matrix.path }}
          MATRIX_VERSION: ${{ matrix.version }}
        run: |
          PKG="$MATRIX_PATH"
          VERSION="$MATRIX_VERSION"
          COMPONENT_NAME="workflows-$(echo "$PKG" | cut -d'/' -f2- | tr '/' '-')"
          TAG_NAME="${COMPONENT_NAME}-v${VERSION}"
          META_TAG_NAME="${COMPONENT_NAME}-meta-v${VERSION}"
          TARGET_FILE="${COMPONENT_NAME#workflows-}.yaml"

          echo "pkg=$PKG" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "component_name=$COMPONENT_NAME" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "meta_tag_name=$META_TAG_NAME" >> $GITHUB_OUTPUT
          echo "target_file=$TARGET_FILE" >> $GITHUB_OUTPUT

      - name: Get Release Notes
        id: notes
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
          PKG: ${{ steps.vars.outputs.pkg }}
          VERSION: ${{ steps.vars.outputs.version }}
        run: |
          NOTES="Release $PKG $VERSION"
          CURRENT_SHA=$(git rev-parse HEAD)
          PR_NUMBER=$(gh pr list --search "$CURRENT_SHA" --state merged --json number --jq '.[0].number')

          if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
              echo "Found PR #$PR_NUMBER"
              PR_BODY=$(gh pr view "$PR_NUMBER" --json body --jq .body)
              if [ -n "$PR_BODY" ]; then
                # Escape output for multiline strings
                EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
                echo "release_notes<<$EOF" >> $GITHUB_OUTPUT
                echo "$PR_BODY" >> $GITHUB_OUTPUT
                echo "$EOF" >> $GITHUB_OUTPUT
                
                echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
              fi
          fi

          if [ -z "$PR_BODY" ]; then
              echo "release_notes=$NOTES" >> $GITHUB_OUTPUT
          fi

          # Capture the SHA of main (HEAD) before we switch branches for the clean release
          echo "main_sha=$CURRENT_SHA" >> $GITHUB_OUTPUT

      - name: Prepare Release Artifacts
        id: prepare_artifacts
        env:
          PKG: ${{ steps.vars.outputs.pkg }}
          TARGET_FILE: ${{ steps.vars.outputs.target_file }}
        run: |
          # Create distro directory for release artifacts
          DIST_DIR="release_dist"
          mkdir -p "$DIST_DIR"

          # safe extract dir
          mkdir -p /tmp/pkg_content

          # Copy content to temp dir to avoid polluting workspace
          if [ -d "$PKG" ]; then
            cp -r "${PKG}/." /tmp/pkg_content/
          else
            echo "Error: Package directory $PKG does not exist"
            exit 1
          fi

          # Distribute Files to DIST_DIR
          # We reconstruct the file tree here to ensure a clean release
          mkdir -p "$DIST_DIR/.github/workflows"

          shopt -s dotglob
          for FILE in /tmp/pkg_content/*; do
              BASENAME=$(basename "$FILE")
              if [ "$BASENAME" == "README.md" ] || [ "$BASENAME" == "CHANGELOG.md" ]; then
                  cp -r "$FILE" "$DIST_DIR/"
              elif [ "$BASENAME" == "workflow.yaml" ]; then
                  cp "$FILE" "$DIST_DIR/.github/workflows/$TARGET_FILE"
              else
                  cp -r "$FILE" "$DIST_DIR/.github/workflows/"
              fi
          done
          shopt -u dotglob

          echo "dist_dir=$DIST_DIR" >> $GITHUB_OUTPUT

      - name: Create Release Tree
        id: create_tree
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          DIST_DIR: ${{ steps.prepare_artifacts.outputs.dist_dir }}
        with:
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            const fs = require('fs/promises');
            const path = require('path');
            const { DIST_DIR } = process.env;

            // Helper to list all files recursively
            async function getFiles(dir) {
              const globber = await glob.create(`${dir}/**/*`, { followSymbolicLinks: false, implicitDescendants: false });
              const files = await globber.glob();
              return files.filter(f => !f.endsWith(path.sep)); // Exclude directories
            }

            const distPath = path.resolve(DIST_DIR);
            const files = await getFiles(distPath);
            const treeItems = [];

            // iterate over files and create blobs
            for (const file of files) {
              const stats = await fs.stat(file);
              if (stats.isDirectory()) continue;

              const relativePath = path.relative(distPath, file).replace(/\\/g, '/'); // Normalize paths
              const content = await fs.readFile(file, { encoding: 'base64' });
              
              const { data: blob } = await github.rest.git.createBlob({
                ...context.repo,
                content: content,
                encoding: 'base64',
              });

              const stats = await fs.stat(file);
              const isExecutable = !!(stats.mode & 0o100);
              const mode = isExecutable ? '100755' : '100644';

              treeItems.push({
                path: relativePath,
                mode: mode,
                type: 'blob',
                sha: blob.sha,
              });
            }

            console.log(`Creating tree with ${treeItems.length} files...`);
            const { data: tree } = await github.rest.git.createTree({
              ...context.repo,
              tree: treeItems,
            });
            console.log(`Tree created: ${tree.sha}`);
            core.setOutput('tree_sha', tree.sha);

      - name: Create Release Commit
        id: create_commit
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          TREE_SHA: ${{ steps.create_tree.outputs.tree_sha }}
          MAIN_SHA: ${{ steps.notes.outputs.main_sha }}
          COMPONENT_NAME: ${{ steps.vars.outputs.component_name }}
          VERSION: ${{ steps.vars.outputs.version }}
        with:
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            const { TREE_SHA, MAIN_SHA, COMPONENT_NAME, VERSION } = process.env;

            console.log(`Creating commit for ${COMPONENT_NAME} ${VERSION}...`);
            const { data: commit } = await github.rest.git.createCommit({
              ...context.repo,
              message: `chore: release ${COMPONENT_NAME} ${VERSION}`,
              tree: TREE_SHA,
              parents: [MAIN_SHA], // Parent is the main branch commit to ensure history continuity
            });
            console.log(`Commit created: ${commit.sha}`);
            core.setOutput('commit_sha', commit.sha);

      - name: Create Release Tags
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          COMMIT_SHA: ${{ steps.create_commit.outputs.commit_sha }}
          TAG_NAME: ${{ steps.vars.outputs.tag_name }}
          COMPONENT_NAME: ${{ steps.vars.outputs.component_name }}
          VERSION: ${{ steps.vars.outputs.version }}
        with:
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            const { COMMIT_SHA, TAG_NAME, COMPONENT_NAME, VERSION } = process.env;
            // 1. Create Annotated Tag for Release
            console.log(`Creating annotated tag object for ${TAG_NAME}...`);
            const { data: tagObject } = await github.rest.git.createTag({
              ...context.repo,
              tag: TAG_NAME,
              message: `Release ${COMPONENT_NAME} ${VERSION}`,
              object: COMMIT_SHA,
              type: 'commit',
            });

            console.log(`Creating ref refs/tags/${TAG_NAME}...`);
            await github.rest.git.createRef({
              ...context.repo,
              ref: `refs/tags/${TAG_NAME}`,
              sha: tagObject.sha,
            });

      - name: Create Meta Tag
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          META_TAG_NAME: ${{ steps.vars.outputs.meta_tag_name }}
          MAIN_SHA: ${{ steps.notes.outputs.main_sha }}
        with:
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            const { META_TAG_NAME, MAIN_SHA } = process.env;
            // 2. Create Meta Tag
            try {
               await github.rest.git.getRef({ ...context.repo, ref: `tags/${META_TAG_NAME}` });
               console.log(`Meta tag ${META_TAG_NAME} already exists.`);
            } catch (e) {
               console.log(`Creating meta tag ref ${META_TAG_NAME} on ${MAIN_SHA}...`);
               await github.rest.git.createRef({
                 ...context.repo,
                 ref: `refs/tags/${META_TAG_NAME}`,
                 sha: MAIN_SHA,
               });
            }

      - name: Create Release
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
          TAG_NAME: ${{ steps.vars.outputs.tag_name }}
          COMPONENT_NAME: ${{ steps.vars.outputs.component_name }}
          VERSION: ${{ steps.vars.outputs.version }}
          NOTES: ${{ steps.notes.outputs.release_notes }}
          REPO: ${{ github.repository }}
        run: |
          gh release create "$TAG_NAME" --title "${COMPONENT_NAME} ${VERSION}" --notes "$NOTES" -R "$REPO"

      - name: Update PR Labels
        if: always() && steps.notes.outputs.pr_number != ''
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
          PR_NUMBER: ${{ steps.notes.outputs.pr_number }}
        run: |
          echo "Updating labels for PR #$PR_NUMBER"
          gh pr edit "$PR_NUMBER" --remove-label "autorelease: pending" --add-label "autorelease: tagged" || echo "Label update failed/skipped"
